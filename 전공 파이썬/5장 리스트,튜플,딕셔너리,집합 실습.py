"""22.10.09 작성<5장 리스트(list) 튜플(tuple) 딕셔너리(dictionary) 집합(set)> """



                                    #  <리스트(list) 란>
# 순서가 지정된 요소(item) 모음을 저장하는 자료구조
# 리스트는 아무것도 포함하지 않는 비어있는 리스트 구조도 가능
# 숫자나 문자열을 요솟값으로 가질수도 있음
# 다른 리스트를 요소로 가질 수도 있음(리스트 내의 리스트 구조, 2차원 리스트)
# 형식:  list이름=[요소1,요소2....요소n]     (인덱스 번호는 [0]~[n-1]==[-1]까지 임을 유의)

list1=[20180876, "천민우",True,3.14]    #정수형,문자열 bool형이 동시에 존재가 가능 하다.
list2=["파이썬", " 프로그래밍"]
listalpabet=['a','b','c','d','e']
enptylist=[]    #빈리스트만 생성
allinlist=[list1,list2,listalpabet,enptylist]    #리스트 속에 다른 리스트가 들어가 있음

print(list1)
print(list2)
print(listalpabet)

print(type(list1))    #class list 라고 출력 된다.
print(type(list2))
print(type(listalpabet))






                                # <리스트의 인덱싱과 슬라이싱 기능>
# 인덱싱 기초
# 리스트이름[0] : 리스트의 첫번쨰 요소 반환
# 리스트이름[-1] : 리스트의 마지막 요소 반환
# 리스트이름[n:] : 리스트의 [n]~[-1]까지 슬라이싱
# 리스트이름[:n] : 리스트의 [0]~[n-1]까지 슬라이싱(n은 범위에 포함되지 않는다.)
# 슬라이싱 기본 형식: [시작인덱스:종료인덱스:step(증감값)] 종료인덱스-1까지 실제로 자른다. step은 생략 가능(기본으로 인덱스 1씩 처리)

print("-------------------------------")
print(list1[0])
print(list2[1])
print(allinlist[0][0])    # 리스트속의 리스트에서 요소를 끄집에 내는 과정

mlist=['1','2','3','4','5','6','7','8','9','10']
print(mlist[1:])    #[1]부터 출력이 된다.
print(mlist[:4])    # 1,2,3,4 까지 출력됨 [4]는 범위에 포함 X

mlist2=mlist[2:9]    #index[2]~[8]까지 잘라서 다른 리스트를 생성
print(mlist2)    # 3, 4, 5, 6, 7, 8, 9 출력된다.
print("--------------------------------------")






                     
                     # <리스트가 아닌걸 리스트화 하는법 list() 활용>
list99=list("0123456789")    #리스트화를 진행해서 한글자가 한 인덱스에 들어간다.
print(list99)    # ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] 출력된다.

list99[0]='100'    # 직접적으로 리스트인덱스의 요소에 접근해서 수정이 가능하다는 점.
print(list99)    






                            # <리스트의 메소드와 함수>   ****중요***** (실체값=담겨있는 내용물이라 생각)

# append() : list_name.append(n) , 리스트의 맨 마지막에 n을 추가한다.  (n은 실체값)
# clear() : list_name.clear()  ,  리스트의 모든 요소를 제거(빈리스트화) 한다.
# copy() : list_name.copy()  ,  리스트를 통째로 복사
# count() : list_name.count(n)  ,  리스트 안에 n 값이 몇개 들어 있는지 세주고 반환  (n은 실체값)
# del() : del(list_name[x])  ,  리스트의 [x]를 삭제하는 기능   (x는 인덱스 번호)
# extend() : list_name.extend(다른리스트 이름)  ,  기존 리스트의 뒤에 다른 리스트를 붙여주는 기능
# index() : list_name.index(n)  ,  리스트에 요소값n이 위치의 인덱스 번호를 반환한다.(n은 실체값)
# insert() : list_name.insert(a,b)  ,  리스트의 a번째 위치에 값b를 삽입한다. (a는 인덱스번호, b는 실체값)

# pop()  :  list_name.pop()  ,  리스트의 맨 마지막 요소를 출력하고 삭제(pop(x)를 해주면 인덱스 번호 x에 위치한 값 반환후 삭제 실행)
# remove() : list_name.remove(x)  ,  리스트의 처음부터 값x를 검색하고 존재하면 삭제한다. 없으면 ValueError발생 (x는 실체값)
# reverse() : list_name.reverse()  ,  리스트의 순서를 뒤집는다(처음게 끝으로감)
# sort() : list_name.sort()  ,  리스트를 오름차순으로 정렬한다.(만약 문자열이라면 알파벳 a,b,c,d ...순으로 정렬)
    # 내림차순으로 정렬시 reverse 옵션을 사용
    # 리스트에서 sort()를 사용할때는 모든 요소의 자료형이 같아야 한다(한가지 자료형으로 통일해야만 비교후 정렬이 가능하기 떄문)
    # 여러 자료형이 섞여있으면 TypeError 발생한다.
# len() : len(list_name)  , 리스트의 전체 길이를 반환한다.(요소의 개수와 같다)
# max() : max(list_name)  ,  리스트에서 가장 큰 값을 반환 한다.
# min() : min(list_name)  ,  리스트에서 가장 작은 값을 반환 한다.
# list()  :  list(다른 자료구조 변수명)  ,  해당 자료구조를 list형으로 변환한다.

print("---------------------------------------------------------------------------")

#append
list1=[1,2,3]
list1.append(100)    #요소값 100을 뒤에 추가
list1.append([4,5,6])     #list1의 뒤에 리스트 [4,5,6] 을 한번에 추가함
print(list1)    #[1, 2, 3, 100, [4, 5, 6]] 식으로 완료

#clear
list1.clear()    #list1을 전부 비워준다.
print(list1)    #[] 출력됨

#copy
list2=[1,2,3,4,5,6]
list3=list2.copy()    #list2를 복사해서 list3에 넣어준다.    (아랫줄들 모두 같은 기능, 의미임)
list3=list2    #copy와 같은 의미
list3=list([1,2,3,4,5,6])    #위와 같은 의미
list3=list(list2)    #위와 같은 의미

print(list3)    #[1, 2, 3, 4, 5, 6] 가 출력됨

#count
list1=[1,1,1,2,3,4,5,6]
print(list1.count(1))    #리스트 내의 요소값 정수1 이 몇개인지 세준다. (3개 들어 있음)

#del
list1=['안','녕','하','세','요']
del(list1[0])    # '안' 삭제됨
print(list1)    # ['녕', '하', '세', '요'] 출력됨

#extend
a=[1,2,3]
b=['밥','먹','자']
a.extend(b)    # 리스트 a에 리스트 b를 붙여준다.
print(a)

#index
list1="가나다라마바사"    #문자열도 리스트 형태로 저장된다는 사실
print(list1.index('라'))    # 3이 출력됨 (해당요소값으 인덱스 번호가 반환됨앞에서부터 4번째에 존재)

#insert
list1=[1,2,3,4,5]
list1.insert(3,"개미")    #인덱스 번호 3번에 "개미"를 삽입(뒤에값은 한칸씩 밀려남)
print(list1)

#pop
list1=[1,2,3,4,5,6]
print(list1.pop())    #가장 뒤에있는 6이 반환되고 삭제
print(list1)
print(list1.pop(1))    #인덱스번호 1번에 위치한 값이 반횐되고 삭제
print(list1)

# remove
list1=[1,2,3,4,3,2,1]
list1.remove(1)    #가장 앞에서부터  정수1 검색후 존재하면 삭제
list1.remove(2)    #가장 앞에서 부터 정수2 검색후 존재하면 삭제
list1.remove(1)    #가장 앞에서부터  정수1 검색후 존재하면 삭제(2번째 정수 1이 삭제됨)
print(list1)    #[3, 4, 3, 2] 출력된다.

del (list1[list1.index(4)])    #리스트에서 요소값 정수4를 찾고 인덱스 번호를 반환한뒤 del을 사용해 삭제
                                #한마디로 요소를 삭제하고 싶은데 인덱스 번호를 모를때 사용하는 방법(remove가 더 간결)

# reverse 2번째 14:15초 구간에서 다시 정리하자
list1=[0,1,2,3,4,5,6,7,8,9,10]
list1.reverse()
print(list1)    #[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 으로 역순으로 출력된다.

# sort
list1=[1,3,2,7,4,5,6,8,10]    #무작위로 숫자가 들어가 있음
list2=list("aksuvgek")
list1.sort()
list2.sort()

print(list1)    #[1, 2, 3, 4, 5, 6, 7, 8, 10]  으로 오름차순으로 정렬
print(list2)    #['a', 'e', 'g', 'k', 'k', 's', 'u', 'v'] 으로 알파벳 문자도 정렬이 가능하다.

    #내림차순으로 정렬하는 법
list1.sort(reverse=True)    #괄호 내부에 reverse=True 를 입력하면 오름차순이 아닌 내림차순으로 출력이 된다.
print(list1)    #[10, 8, 7, 6, 5, 4, 3, 2, 1]

    #정렬한걸 복사하는 sorted()  **원본에 영향을 주지 않는걸 유의**
listA=[1,7,2,6,3,4,5]
listB=sorted(listA)    #sorted()를 사용해서 원본에 영향을 주지않고 정렬후 복사가 진행 된다는점을 유의하자
print(listA,"\n",listB)

    #문자열을 리스트로 만든뒤 요소의 길이순으로 오름차순or 내림차순 정렬한다.
listA=list("나는 파이썬 프로그래밍 과목을 매우 좋아한다는 점".split())    #문자열을 공백문자 기준으로 잘라서 리스트에 넣는다.
print(listA)    #['나는', '파이썬', '프로그래밍', '과목을', '매우', '좋아한다는', '점']  출력된다.
listA.sort(key=len ,reverse=True)    #listA를 len(길이)를 기준으로 내림차순으로 정렬한다는 의미(key=len)이 핵심
print(listA)    #['프로그래밍', '좋아한다는', '파이썬', '과목을', '나는', '매우', '점'] 출력된다.

    #sort()사용시 주의점(요소들의 자료형이 하나로 같아야 한다(통일성))
list1=[123,"123"]
#sort(list1)    #TypeError 발생한다.


#in검사 (리스트 내의 해당 요소값이 들어가 있는지 검사, 결과값은 Bool형이다.)
    #나중에 if문과 연계해서 검사하는 알고리즘으로도 응용이 가능한 부분이다.
a=[1,4,2,3,5]
print(1 in a)    #리스트a에 정수1이 존재하는가
print(10 in a)    #리스트a에 정수 10이 존재하는가
print(10 not in a)    #리스트a에 정수 10이 존재하지 않는가











                      #<리스트의 연산>   (연결연산(+), 반복연산(*), 비교연산(==, !=, <, >))

# 연결연산(+) : 두 리스트를 연결하는 연산으로 좌항 리스트의 끝+ 우항 리스트의 시작으로 연결된다.
# 반복연산(*) : (리스트 * n) 형식으로 사용, 리스트를 n번 반복해서 출력or 대입시 사용
# 비교연산(==, !=, <, >)
    # ==연산 : 두 리스트가 같은지 비교(요소의 값과 순서 모든게 일치해야 참)
    # !=연산 : 두 리스트가 다른지 비교
    # <, > : 두 리스트의 대-소를 비겨하는 연산을 두 리스트의 요소를 사전적 순서로 비교하여 결과를 반환


#range()함수: 연속된 수를 생성하는 함수를 활용해서 리스트 생성
list1=list(range(10))
print(list1)    #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 출력된다.

list2=list(range(-10,10,1))    #시작 -10 종료 10 증감속도 1
print(list2)    #[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 출력된다.

#sum()
list1=list(range(10))
print(sum(list1))    #리스트의 모든 요소를 합한걸 반환  45

#max
print(max(list1))    #리스트 요소값중에 가장 큰값을 반환  9

#min
print(min(list1))    #리스트 요소값중에 가장 작은값을 반환  0

#len
print(len(list1))    #리스트의 길이(요소값의 개수) 출력  10
avg=sum(list1)/len(list1)    #리스트의 평균값 구하시(sum과 len 활용)
print(avg)


#list의 +연산
list1=[1,2,3]
list2=[4,5,6]
list3=list1+list2
list3+=list1
print(list3)    #[1, 2, 3, 4, 5, 6, 1, 2, 3] 출력된다.


#list의 *연산
list1=[1,2,3]
list2=list1*3
print(list2)    #[1, 2, 3, 1, 2, 3, 1, 2, 3] 출력된다.

#list의 == 연산(Bool 값으로 반환된다.)
list1=[1,2,3,4,5]
list2=[1,2,3,4,5]
list3=[2,1,3,4,5]

print(list1==list2)    #list1과 list2가 완전히 같은지 확인(인덱스 번호,요소값 모든게 일치하면 True 반환)
print(list1==list3)    #False 출력된다. 0번1번 인덱스 요소가 다르기 때문

#list의 >,< 비교연산    (리스트 인덱스에서 처음 나오는 값을 비교하고 크면 True이다, 뒤에 어떤 값이 오는지 상관하지 않음)
list1=[1,2,500]
list2=[1,3,2]
print(list1<list2)    #list1[1] < list2[1] 이기 때문이다. (각각 인덱스 0번은 같아서 다음 인덱스로 넘어감)




#                   ******************<튜플(tuple) 정의>*****************

# 튜플은 리스트처럼 요소를 일렬로 저장하고 콤마로 구분한다.
# 형식: tuple_name=(요소1, 요소2, 요소3, 요소4, 요소5)

# <리스트와의 차이점>
# 첫째: list는 [] 묶어주지만 튜플은 () 으로 묶어준다.(이떄 괄호를 생략하는것도 가능하다.)
# 둘쨰: tuple은 요소의 수정,추가, 부분삭제가 불가능 하다(처음 만들때 이후로 봉인된다.)



#                                  <튜플의 메소드와 함수>
# count(): tuple_name.count(x)  ,  튜플에서 요소값 x가 몇개 들어가 있는지 반환
# index(): tuple_name.index(x)  ,  튜플에서 요소값 x가 있으면 해당 인덱스넘버를 반환
# len(): len(tuple_name)  ,  튜플의 요소의 길이(개수)를 반환한다.
# max(): max(tuple_name)  ,  튜플의 요소값중 가장 큰 값을 반환한다.
# min(): min(tuple_name)  ,  튜플의 요소값중 가장 작은 값을 반환한다.
# sum(): sum(tuple_name)  ,  튜플의 요소값을 모두 더해서 반환한다.
# tuple(): tuple(다른 자료구조)  ,  다른 자료구조를 tuple로 변환한다.

# tuple도 연결연산(+) 반복연산(*) 비교연산(>,<) 을 리스트처럼 사용이 가능하다.



# tuple
T1=()    #빈 튜플 생성
T2=tuple(range(10))    #0~9까지 정수를 튜플로 만듬
print(type(T1))    #tuple로 인식됨
print(T2)

T3=(1)
type(T3)    #int로 인식함

T4=(1,)
type(T4)    #tuple로 인식함(콤마(,)가 존재하기 때문)

T5=('a','b',('a1','b1','b3'))    #튜플내에 튜플이 존재가 가능(2차원 튜플)
print(T5)

T6=T5+T4
print(T6)     #튜플의 + 연산 활용

# 튜플은 요소 삭제가 불가능 하다.
#del(T6[0])    # TypeError: 'tuple' object doesn't support item deletion


# 튜플과 리스트의 상호 변환 과정
mytuple=(1,2,3,4,5)
print(mytuple)    #(1, 2, 3, 4, 5) 출력

mylist=list(mytuple)    # 튜플을 리스트로 변환함
mylist.append(6)    #리스트에 6 추가
print(mylist)    #[1, 2, 3, 4, 5, 6]  출력

mytuple=tuple(mylist)    #리스트를 튜플로 변환
print(mytuple)     #(1, 2, 3, 4, 5, 6)  출력

# 튜플과 리스트를 활용한 자료형 한번에 저장하기
a,b,c=[1,2,3]
a1,b1,c1=(11,22,33)
print(a,b,c)
print(type(a))     # int형이다.
print(a1,b1,c1)
print(type(a1))     # int형이다.


#                          <튜플의 함수와 메소드> *******중요***********
TA=(1,2,3,4,1,2,3,1,2,3,4,)
print(TA.count(1))    #요소값 1은 3개 존재
print(TA.index(3))    #가장 처음 만나는 요소값 3을 가진 인덱스 번호를 검색 (2출력)
print(len(TA))    #튜플의 길이(요소의 개수) 출력
print(max(TA))    #튜플내에서 가장큰 요소값을 반환
print(min(TA))    #튜플내에서 가장 작은 요소값을 반환
print(sum(TA))    #튜플내 요소들의 모든 합을 반환한다.  

# 튜플의 +, *, ==, <, > 연산
T1=(1,2,3)
T2= (4,5,6)
T3=T1+T2     # +연산 활용
T4=T3*2     # * 연산 활용
print(T3)    # (1, 2, 3, 4, 5, 6) 출력 된다.
print(T4)    # (1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6) 출력 된다. 

print(T3==T4)
print(T3<T4)    #인덱스 5번까지는 모든 요소가 일치하지만  T4가 요소값의 개수가 더 많기 떄문에 True 가 출력된다.

T3=(2,1,1)
T4=(1,100,100,100)
print(T3>T4)    #True 가 출력 된다. 첫번째 요소들을 비교했을때 T3가 더 크기 때문이다.

#tuple()
T1=tuple(range(10))    #(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) 들어간다.
T2 = tuple(range(-5,5,2))    #(-5, -3, -1, 1, 3) 들어간다.
print(T1)
print(T2)