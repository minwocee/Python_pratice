"""
3  # 테스트 케이스 개수 

<입력1>
1 0    #(문서의개수) / (알고싶은 문서의 배치 위치 (가장 왼쪽을 0 이라고 가정한다)
5      #문서의 중요도
<출력1>
1     #하나만 존재 하므로 

<입력2>
4 2     # 문서의 개수 / 알고싶은 문서의 배치 위치(왼쪽에서 부터 3번째 칸, 인덱스 번호 처럼)
1 2 3 4     #문서의 중요도 (내가 알고싶은 문서의 중요도는 3이다)
<출력2>
2

<입력3>
6 0     # 문서의 개수 / 알고싶은 문서의 배치 위치 (가장 왼쪽에 있는 칸을 의미한다.)
1 1 9 1 1 1
<출력3>
5

같은 문자열일때의 경우는 따로 생각해봐야 된다.
11(2)233일때 해달 문자열이 나오는 경우는

(0)일떄 5
(1)일때 6
(3)일때 2
(4)일떄 3
(5)일때 4

"""
"""
insert(x)를 활용해서 해당 문자열이 무엇인지 알아낸다
해당 문자열을 '1a'로 바꾼뒤 
"""

import sys

T = int(sys.stdin.readline())

for _ in range(T):
    N , M = map(int, sys.stdin.readline().split())
    Table = list(map(int , sys.stdin.readline().split()))
    My_TT = list(range(len(Table)))      #인덱스 비교용 배열
    My_TT[M] ='1'    #내가 고른 카드의 위치인덱스를 저장하는 배열에서 해당 위치를 '1' 로 바꿔 준다. ( 0,1,2, '1',4 ,5 ..) 이런식으로 담겨 있음

    counter = 0
    while (True):
        # 비교를 시작 하자
        if Table[0]==max(Table):
            counter+=1 # 일단 pop 조건을 만족하면 실행을 한다.
            if My_TT[0]=='1':     #만약 해당 인덱스가 내가 찾는 위치에 있는 수이다 하면 출력해주고 무한 반복문을 중지 한다.
                print(counter)
                break
            else:     # MY_TT랑 Table랑 동시에 돌려보는 반복문이라고 생각을 하면 편하게 출력이 가능한다.
                Table.pop(0)
                My_TT.pop(0)
        else:    #첫번쨰 오는 애가 가장 큰애가 아닌 경우 다시 뒤로 되돌려 주어야 하기 때문이다.
            Table.append(Table.pop(0))
            My_TT.append(My_TT.pop(0))


