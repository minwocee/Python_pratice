"""
문제
당신은 유명 프로그래밍 대회인 KCPC(Korean Collegiate Programming Contest)에 참가하고 있다.
 이 대회에서 총 k개의 문제를 풀게 되는데, 어떤 문제에 대한 풀이를 서버에 제출하면 그 문제에 대해 0점에서 100점 사이의 점수를 얻는다. 
 풀이를 제출한 팀의 ID, 문제 번호, 점수가 서버의 로그에 제출되는 시간 순서대로 저장된다. 한 문제에 대한 풀이를 여러 번 제출할 수 있는데, 
 그 중 최고 점수가 그 문제에 대한 최종 점수가 된다. (만약 어떤 문제에 대해 풀이를 한번도 제출하지 않았으면 그 문제에 대한 최종 점수는 0점이다.) 

당신 팀의 최종 점수는 각 문제에 대해 받은 점수의 총합이고, 당신의 순위는 (당신 팀보다 높은 점수를 받은 팀의 수)+1 이다. 

점수가 동일한 팀이 여럿 있을 수 있는데, 그 경우에는 다음 규칙에 의해서 순위가 정해진다. 

1. 최종 점수가 같은 경우, 풀이를 제출한 횟수가 적은 팀의 순위가 높다. (트라이 횟수 적은팀) 
2. 최종 점수도 같고 제출 횟수도 같은 경우, 마지막 제출 시간이 더 빠른 팀의 순위가 높다. (둘다 잘했을때 제출 시간이 우선 순위) 
3. 동시에 제출되는 풀이는 없고, 모든 팀이 적어도 한 번은 풀이를 제출한다고 가정하라. 

서버의 로그가 주어졌을 때, 당신 팀의 순위를 계산하는 프로그램을 작성하시오.



입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 
입력의 첫 번째 줄에는 테스트 데이터의 수를 나타내는 정수 T가 주어진다. 
각 테스트 데이터의 첫 번째 줄에는 팀의 개수 n, 
문제의 개수 k, 
당신 팀의 ID t, 
로그 엔트리의 개수 m을 나타내는 4 개의 정수가 주어진다. 
여기서, 3 ≤ n, k ≤ 100, 1 ≤ t ≤ n, 3 ≤ m ≤ 10,000이다. 
그 다음 m개의 줄에는 각 풀이에 대한 정보가 제출되는 순서대로 주어진다. 
각 줄에는 팀 ID i, 문제 번호 j, 획득한 점수 s를 나타내는 세 개의 정수가 주어진다. 여기서 1 ≤ i ≤ n, 1 ≤ j ≤ k, 0 ≤ s ≤ 100이다. 

내 팀의 순위를 보여주면 끝이다.

T(테스트 데이터 개수)

n(참여팀의 개수) k(KCPC문제의 개수) t(내 팀의 ID) m(로그 엔트리의 개수-아래에 적히는 기록들이 몇줄인지를 의미)

i(적팀 ID) j(문제의 번호) s(획득한 점수) 

n+m이 입력받는 3번쨰줄 이하부터의 개수를 의미 하는것 같다         
출력
출력은 표준출력을 사용한다. 주어진 각 테스트 데이터에 대해 당신 팀의 순위를 한 줄에 출력하여야 한다
"""


"""
2(총 테스트 케이스 실행 횟수)

<test1>
3 4 3 5    (팀수, 문제수, 내팀번호, 로그개수)
1 1 30    (팀id, 문제번호, 획득점수)
2 3 30
1 2 40
1 2 20
3 1 70

1팀: 90점
2팀: 30점
3팀(내팀): 70점 (2등)

<test2>
4 4 1 10    (팀수, 문제수, 내팀번호, 로그개수)
1 1 50
2 1 20
1 1 80
3 1 0
1 2 20
2 2 10
4 3 0
2 1 0
2 2 100
1 4 20

<동점자 풀이 규칙> 
1. 최종 점수가 같은 경우, 풀이를 제출한 횟수가 적은 팀의 순위가 높다. (트라이 횟수 적은팀) 
2. 최종 점수도 같고 제출 횟수도 같은 경우, 마지막 제출 시간이 더 빠른 팀의 순위가 높다. (둘다 잘했을때 제출 시간이 우선 순위) 
3. 동시에 제출되는 풀이는 없고, 모든 팀이 적어도 한 번은 풀이를 제출한다고 가정하라. 
"""

import sys

T = int(sys.stdin.readline())    # 테스트셋의 개수

for _ in range(T):
    team_many, test_many, myteam_id, log_many = map(int,sys.stdin.readline().split())    #팀수, 문제수, 내팀, 로그수
    log_list=[]
    Table=[[0]*(test_many+2) for _ in range(team_many)]
    #print(Table)    #[[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
    
    for _ in range(log_many):    # 로그를 입력 받아 온다.
        log_list.append(list(map(int, sys.stdin.readline().split()))) #팀, 문제, 점수 
    
    #2 3 30

    #1번2번3번4번트라이횟수,마지막제출
    #[[0, 0, 0, 0, 0, 0], 
    # [0, 0, 0, 0, 0, 0], 
    # [0, 0, 0, 0, 0, 0]]
    indexcounter=0
    for i in log_list:
        Table[i[0]-1][i[1]-1]=max(i[2], Table[i[0]-1][i[1]-1])
        Table[i[0]-1][test_many]=indexcounter #최종 제출의 인덱스 시간
        indexcounter+=1
        Table[i[0]-1][-1]+=1   #트라이횟수
    
    #print(Table)    #[[30, 40, 0, 0, 3, 3], [0, 0, 30, 0, 1, 1], [70, 0, 0, 0, 4, 1]] 출력됨

    ans=[]
    for _ in range(team_many):    # 리스트 슬라이싱을 통해서 총 점수를 계산
        ans.append(sum(list(Table[_][0:test_many])))

    #타겟값 탐지 시작
    king=ans[myteam_id-1]
    """
    <동점자 풀이 규칙> 
    1. 최종 점수가 같은 경우, 풀이를 제출한 횟수가 적은 팀의 순위가 높다. (트라이 횟수 적은팀) 
    2. 최종 점수도 같고 제출 횟수도 같은 경우, 마지막 제출 시간이 더 빠른 팀의 순위가 높다. (둘다 잘했을때 제출 시간이 우선 순위) 
    3. 동시에 제출되는 풀이는 없고, 모든 팀이 적어도 한 번은 풀이를 제출한다고 가정하라. 
    """
    # 점수 검색을 검사 한다.
    score=1
    for i in range(len(ans)):
        if king < ans[i]:    #나보다크면 등수 1 내려감 발생
            score+=1
        elif king==ans[i]:    #만약 나와 똑같은 점수가 존재한다? 우선 순위 비교 하기
            if Table[myteam_id-1][-1] > Table[i][-1]:   #우리 팀 트라이 횟수가 쟤네팀 트라이 횟수보다 높음
                score+=1
            elif Table[myteam_id-1][-1] == Table[i][-1]:    #트라이 횟수도 똑같음
                if Table[myteam_id-1][-2] > Table[i][-2]:   #제출시간비교
                    score+=1
    print(score)
    # 일단 적어두고 생각을 하자 너무 머리가 아픈 문제 였다...


    